/*
/////////////////////////////////////////////////////////////////////////////////////////
//
//  This file is part of Wachdienst-Manager, a program to manage DLRG watch duty reports.
//  Copyright (C) 2021–2022 M. Frohne
//
//  Wachdienst-Manager is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Affero General Public License as published
//  by the Free Software Foundation, either version 3 of the License,
//  or (at your option) any later version.
//
//  Wachdienst-Manager is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
//  See the GNU Affero General Public License for more details.
//
//  You should have received a copy of the GNU Affero General Public License
//  along with Wachdienst-Manager. If not, see <https://www.gnu.org/licenses/>.
//
/////////////////////////////////////////////////////////////////////////////////////////
*/

#include "person.h"

/*!
 * \brief Constructor.
 *
 * Creates a person with first name \p pFirstName, last name \p pLastName, identifier \p pIdent, qualifications \p pQualifications.
 * \p pActive defines, if the person is an active member and should be enabled/usable in a Report.
 *
 * \param pLastName Person's last name.
 * \param pFirstName Person's first name.
 * \param pIdent Identifier generated by createInternalIdent() or createExternalIdent().
 * \param pQualifications Person's qualifications.
 * \param pActive Person active/enabled?
 */
Person::Person(QString pLastName, QString pFirstName, QString pIdent, struct Qualifications pQualifications, bool pActive) :
    lastName(std::move(pLastName)),
    firstName(std::move(pFirstName)),
    identifier(std::move(pIdent)),
    qualifications(pQualifications),
    active(pActive)
{

}

//Public

/*!
 * \brief Create a dummy person with empty properties.
 *
 * Name and identifier are set empty, there are no qualifications, person is set active.
 *
 * \return A new dummy person.
 */
Person Person::dummyPerson()
{
    return Person("", "", "", Qualifications(QStringList{}), true);
}

//

/*!
 * \brief Create person identifier for internal personnel.
 *
 * Starts with an 'i' followed by first letter of \p pFirstName and first letter of \p pLastName followed by \p pMembershipNumber.
 * Due to the membership number this identifier is intended to be unique.
 *
 * \param pLastName Last name of the person.
 * \param pFirstName First name of the person.
 * \param pMembershipNumber Membership number of the person.
 * \return The identifier.
 */
QString Person::createInternalIdent(const QString& pLastName, const QString& pFirstName, const QString& pMembershipNumber)
{
    return "i" + pFirstName.left(1) + pLastName.left(1) + pMembershipNumber;
}

/*!
 * \brief Create person identifier for internal personnel.
 *
 * Starts with an 'e' followed by first letter of \p pFirstName and first letter of \p pLastName followed by a hash
 * made from a mixture of name and qualifications. Unlike with createInternalIdent(), here only some level of uniqueness
 * is introduced by the hash and hence a suffix \p pSuffix can be provided to distinguish conflicting identifiers.
 * The suffix is appended with a separating period, if not empty.
 *
 * \param pLastName Last name of the person.
 * \param pFirstName First name of the person.
 * \param pQualifications Qualifications of the person.
 * \param pSuffix Identifier suffix (to achieve uniqueness).
 * \return The identifier.
 */
QString Person::createExternalIdent(const QString& pLastName, const QString& pFirstName,
                                    const Qualifications& pQualifications, QString pSuffix)
{
    //Either no suffix or suffix prepended with a dot
    if (pSuffix != "")
        pSuffix.prepend('.');

    QString tRawStr = pLastName + pFirstName + pQualifications.toString();
    QByteArray tByteArray = tRawStr.toUtf8();

    //Use similar format to internal ident; replace membership number by
    //a hash based on person name and qualifications; add suffix (if any)

    return "e" + pFirstName.left(1) + pLastName.left(1) +
            QString::fromStdString(
                QCryptographicHash::hash(tByteArray, QCryptographicHash::Algorithm::Md5).toHex().toStdString()
                ).left(8) + pSuffix;
}

/*!
 * \brief Extract membership number from internal person identifier.
 *
 * Extracts the membership number part of an internal identifier \p pInternalIdent that was generated with createInternalIdent().
 *
 * \param pInternalIdent An internal identifier.
 * \return The membership number.
 */
QString Person::extractMembershipNumber(const QString& pInternalIdent)
{
    return pInternalIdent.mid(3, -1);
}

/*!
 * \brief Extract suffix from external person identifier.
 *
 * Extracts the suffix part of an external identifier \p pExternalIdent that was generated with createExternalIdent().
 *
 * \param pExternalIdent An external identifier.
 * \return The identifier suffix.
 */
QString Person::extractExtSuffix(const QString& pExternalIdent)
{
    QStringList tStrList = pExternalIdent.split('.');

    if (tStrList.size() == 2)
        return tStrList.at(2);

    return "";
}

//

/*!
 * \brief Get the person's last name.
 *
 * \return Person last name.
 */
QString Person::getLastName() const
{
    return lastName;
}

/*!
 * \brief Get the person's first name.
 *
 * \return Person first name.
 */
QString Person::getFirstName() const
{
    return firstName;
}

/*!
 * \brief Get the person's identifier.
 *
 * \return Person identifier.
 */
QString Person::getIdent() const
{
    return identifier;
}

/*!
 * \brief Get the person's qualifications.
 *
 * \return Person qualifications.
 */
struct Person::Qualifications Person::getQualifications() const
{
    return qualifications;
}

/*!
 * \brief Check, if the person is set active.
 *
 * \return Active/enabled state of the person.
 */
bool Person::getActive() const
{
    return active;
}

//

/*!
 * \brief Get the label for a personnel function.
 *
 * Get a (unique) nicely formatted label for \p pFunction to e.g. show it in the application as a combo box item.
 * Converting back is possible using labelToFunction().
 *
 * \param pFunction The personnel function to get a label for.
 * \return The corresponding label for \p pFunction.
 */
QString Person::functionToLabel(Function pFunction)
{
    switch (pFunction)
    {
        case Function::_WF:
            return "WF";
        case Function::_SL:
            return "SL";
        case Function::_BF:
            return "BF";
        case Function::_WR:
            return "WR";
        case Function::_RS:
            return "RS";
        case Function::_PR:
            return "PR";
        case Function::_SAN:
            return "SAN";
        case Function::_FU:
            return "FU";
        case Function::_SR:
            return "SR";
        case Function::_ET:
            return "ET";
        case Function::_FUD:
            return "FüD";
        case Function::_OTHER:
            return "SONST";
        default:
            return "SONST";
    }
}

/*!
 * \brief Get the personnel function from its label.
 *
 * Get the personnel function corresponding to a (unique) label \p pFunction,
 * which can in turn be obtained from functionToLabel().
 *
 * \param pFunction The label representing the requested personnel function.
 * \return The personnel function corresponding to label \p pFunction.
 */
Person::Function Person::labelToFunction(const QString& pFunction)
{
    if (pFunction == "WF")
        return Function::_WF;
    else if (pFunction == "SL")
        return Function::_SL;
    else if (pFunction == "BF")
        return Function::_BF;
    else if (pFunction == "WR")
        return Function::_WR;
    else if (pFunction == "RS")
        return Function::_RS;
    else if (pFunction == "PR")
        return Function::_PR;
    else if (pFunction == "SAN")
        return Function::_SAN;
    else if (pFunction == "FU")
        return Function::_FU;
    else if (pFunction == "SR")
        return Function::_SR;
    else if (pFunction == "ET")
        return Function::_ET;
    else if (pFunction == "FüD")
        return Function::_FUD;
    else if (pFunction == "SONST")
        return Function::_OTHER;
    else
        return Function::_OTHER;
}

/*!
 * \brief Determine the order of two personnel functions.
 *
 * Checks, if \p pFirst should be ordered first with respect to \p pSecond.
 * The result is defined by the Person::Function integer values of \p pFirst
 * and \p pSecond, which are simply compared.
 *
 * \param pFirst Left-hand side of comparison.
 * \param pSecond Right-hand side of comparison.
 * \return 1, if \p pFirst is first, -1, if \p pSecond is first and 0 else.
 */
int Person::functionOrder(Function pFirst, Function pSecond)
{
    if (pFirst == pSecond)
        return 0;

    if (static_cast<int8_t>(pFirst) < static_cast<int8_t>(pSecond))
        return 1;
    else
        return -1;
}

//

/*!
 * \brief Get the label for a boat function.
 *
 * Get a (unique) nicely formatted label for \p pFunction to e.g. show it in the application as a combo box item.
 * Converting back is possible using labelToBoatFunction().
 *
 * \param pFunction The boat function to get a label for.
 * \return The corresponding label for \p pFunction.
 */
QString Person::boatFunctionToLabel(BoatFunction pFunction)
{
    switch (pFunction)
    {
        case BoatFunction::_BG:
            return "BG";
        case BoatFunction::_RS:
            return "RS";
        case BoatFunction::_PR:
            return "PR";
        case BoatFunction::_SAN:
            return "SAN";
        case BoatFunction::_SR:
            return "SR";
        case BoatFunction::_ET:
            return "ET";
        case BoatFunction::_OTHER:
            return "SONST";
        default:
            return "SONST";
    }
}

/*!
 * \brief Get the boat function from its label.
 *
 * Get the boat function corresponding to a (unique) label \p pFunction,
 * which can in turn be obtained from boatFunctionToLabel().
 *
 * \param pFunction The label representing the requested boat function.
 * \return The boat function corresponding to label \p pFunction.
 */
Person::BoatFunction Person::labelToBoatFunction(const QString& pFunction)
{
    if (pFunction == "BG")
        return BoatFunction::_BG;
    else if (pFunction == "RS")
        return BoatFunction::_RS;
    else if (pFunction == "PR")
        return BoatFunction::_PR;
    else if (pFunction == "SAN")
        return BoatFunction::_SAN;
    else if (pFunction == "SR")
        return BoatFunction::_SR;
    else if (pFunction == "ET")
        return BoatFunction::_ET;
    else if (pFunction == "SONST")
        return BoatFunction::_OTHER;
    else
        return BoatFunction::_OTHER;
}

/*!
 * \brief Determine the order of two boat functions.
 *
 * Checks, if \p pFirst should be ordered first with respect to \p pSecond.
 * The result is defined by the Person::BoatFunction integer values of
 * \p pFirst and \p pSecond, which are simply compared.
 *
 * \param pFirst Left-hand side of comparison.
 * \param pSecond Right-hand side of comparison.
 * \return 1, if \p pFirst is first, -1, if \p pSecond is first and 0 else.
 */
int Person::boatFunctionOrder(BoatFunction pFirst, BoatFunction pSecond)
{
    if (pFirst == pSecond)
        return 0;

    if (static_cast<int8_t>(pFirst) < static_cast<int8_t>(pSecond))
        return 1;
    else
        return -1;
}

//Qualifications struct

/*!
 * \brief Constructor.
 *
 * Sets each valid qualification contained in \p pQualifications to true and all others to false.
 *
 * \param pQualifications List of strings containing a single qualification each.
 */
Person::Qualifications::Qualifications(const QStringList& pQualifications) :
    eh(false),
    rsa(false),
    faWrd(false),
    sanA(false),
    bfA(false),
    sr1(false),
    et(false),
    bos(false),
    wf(false),
    zf(false)
{
    for (const QString& quali : pQualifications)
    {
        if (quali == "EH")
            eh = true;
        else if (quali == "RSA")
            rsa = true;
        else if (quali == "FA-WRD")
            faWrd = true;
        else if (quali == "SAN-A")
            sanA = true;
        else if (quali == "BF")
            bfA = true;
        else if (quali == "SR-1")
            sr1 = true;
        else if (quali == "ET")
            et = true;
        else if (quali == "BOS")
            bos = true;
        else if (quali == "WF")
            wf = true;
        else if (quali == "ZUGF")
            zf = true;
    }
}

/*!
 * \brief Constructor.
 *
 * Sets each valid qualification contained in \p pQualifications to true and all others to false.
 * Calls QStringList overload of constructor with list created from \p pQualifications string split at ','.
 *
 * \param pQualifications Comma-separated list of single qualification strings.
 */
Person::Qualifications::Qualifications(const QString& pQualifications) :
    Qualifications(pQualifications.split(','))
{
}

//

/*!
 * \brief List all qualifications in principle available.
 *
 * \return List of strings that can be used in constructor to define qualifications.
 */
QStringList Person::Qualifications::listAllQualifications()
{
    return {"EH", "RSA", "FA-WRD", "SAN-A", "BF", "SR-1", "ET", "BOS", "WF", "ZUGF"};
}

//

/*!
 * \brief Get a comma-separated list of possessed qualifications.
 *
 * \return Possessed qualifications as comma-separated string.
 */
QString Person::Qualifications::toString() const
{
    QString retVal;

    if (eh)
        retVal.append("EH,");
    if (rsa)
        retVal.append("RSA,");
    if (faWrd)
        retVal.append("FA-WRD,");
    if (sanA)
        retVal.append("SAN-A,");
    if (bfA)
        retVal.append("BF,");
    if (sr1)
        retVal.append("SR-1,");
    if (et)
        retVal.append("ET,");
    if (bos)
        retVal.append("BOS,");
    if (wf)
        retVal.append("WF,");
    if (zf)
        retVal.append("ZUGF,");

    if (retVal.endsWith(','))
        retVal.chop(1);

    return retVal;
}
