/*
/////////////////////////////////////////////////////////////////////////////////////////
//
//  This file is part of Wachdienst-Manager, a program to manage DLRG watch duty reports.
//  Copyright (C) 2021–2024 M. Frohne
//
//  Wachdienst-Manager is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Affero General Public License as published
//  by the Free Software Foundation, either version 3 of the License,
//  or (at your option) any later version.
//
//  Wachdienst-Manager is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
//  See the GNU Affero General Public License for more details.
//
//  You should have received a copy of the GNU Affero General Public License
//  along with Wachdienst-Manager. If not, see <https://www.gnu.org/licenses/>.
//
/////////////////////////////////////////////////////////////////////////////////////////
*/

#include "person.h"

#include <QByteArray>
#include <QCryptographicHash>

/*!
 * \brief Constructor.
 *
 * Creates a person with first name \p pFirstName, last name \p pLastName, identifier \p pIdent, qualifications \p pQualifications.
 * \p pActive defines, if the person is an active member and should be enabled/usable in a Report.
 *
 * \param pLastName Person's last name.
 * \param pFirstName Person's first name.
 * \param pIdent Identifier generated by createInternalIdent() or createExternalIdent().
 * \param pQualifications Person's qualifications.
 * \param pActive Person active/enabled?
 */
Person::Person(QString pLastName, QString pFirstName, QString pIdent, const Qualifications pQualifications, const bool pActive) :
    lastName(std::move(pLastName)),
    firstName(std::move(pFirstName)),
    identifier(std::move(pIdent)),
    qualifications(pQualifications),
    active(pActive)
{
}

//Public

/*!
 * \brief Create a dummy person with empty properties.
 *
 * Name and identifier are set empty, there are no qualifications, person is set active.
 *
 * \return A new dummy person.
 */
Person Person::dummyPerson()
{
    return Person("", "", "", Qualifications(QStringList{}), true);
}

//

/*!
 * \brief Create person identifier for internal personnel.
 *
 * Starts with an 'i' followed by first letter of \p pFirstName and first letter of \p pLastName followed by \p pMembershipNumber.
 * Due to the membership number this identifier is intended to be unique.
 *
 * See also PersonnelEditorDialog::PersonType.
 *
 * \param pLastName Last name of the person.
 * \param pFirstName First name of the person.
 * \param pMembershipNumber Membership number of the person.
 * \return The identifier.
 */
QString Person::createInternalIdent(const QString& pLastName, const QString& pFirstName, const QString& pMembershipNumber)
{
    return "i" + pFirstName.left(1) + pLastName.left(1) + pMembershipNumber;
}

/*!
 * \brief Create person identifier for external personnel.
 *
 * Creates a person identifier for external personnel, which starts with the prefix 'e' and
 * contains a hash made from the person name and its qualifications. See createHashedIdent().
 *
 * See also PersonnelEditorDialog::PersonType.
 *
 * \param pLastName Last name of the person.
 * \param pFirstName First name of the person.
 * \param pQualifications Qualifications of the person.
 * \param pSuffix Identifier suffix (to achieve uniqueness).
 * \return The identifier.
 */
QString Person::createExternalIdent(const QString& pLastName, const QString& pFirstName,
                                    const Qualifications& pQualifications, const QString& pSuffix)
{
    return createHashedIdent(pLastName, pFirstName, pQualifications.toString(), 'e', pSuffix);
}

/*!
 * \brief Create legacy person identifier for external personnel.
 *
 * Creates a person identifier for external personnel like in createExternalIdent(),
 * but uses qualifications in the legacy format from software versions before 1.4.0.
 *
 * Here the legacy qualifications must be directly provided as a comma-separated string in order to preserve the old format.
 *
 * \param pLastName Last name of the person.
 * \param pFirstName First name of the person.
 * \param pQualifications Qualifications of the person in legacy format as comma-separated string.
 * \param pSuffix Identifier suffix (to achieve uniqueness).
 * \return The identifier.
 */
QString Person::createLegacyExternalIdent(const QString& pLastName, const QString& pFirstName,
                                          const QString& pQualifications, const QString& pSuffix)
{
    return createHashedIdent(pLastName, pFirstName, pQualifications, 'e', pSuffix);
}

/*!
 * \brief Create person identifier for "other" people.
 *
 * Creates a person identifier for non-personnel people, which do not have qualifications.
 * It starts with the prefix 'o' and contains a hash made from the person name. Unlike with
 * createInternalIdent() or createExternalIdent(), here the level of uniqueness is limited to the
 * uniqueness of the name. A suffix \p pSuffix may be provided to distinguish conflicting identifiers.
 * See createHashedIdent().
 *
 * See also PersonnelEditorDialog::PersonType.
 *
 * \param pLastName Last name of the person.
 * \param pFirstName First name of the person.
 * \param pSuffix Identifier suffix (to achieve uniqueness).
 * \return The identifier.
 */
QString Person::createOtherIdent(const QString& pLastName, const QString& pFirstName, const QString& pSuffix)
{
    return createHashedIdent(pLastName, pFirstName, "", 'o', pSuffix);
}

//

/*!
 * \brief Check if person identifier represents an internal person.
 *
 * Checks if \p pIdent starts with the prefix that is used by createInternalIdent() to mark internal identifiers.
 *
 * \param pIdent The person identifier to check.
 * \return If \p pIdent is an internal person.
 */
bool Person::isInternalIdent(const QString& pIdent)
{
    return pIdent.startsWith('i');
}

/*!
 * \brief Check if person identifier represents an external person.
 *
 * Checks if \p pIdent starts with the prefix that is used by createExternalIdent() to mark external identifiers.
 *
 * \param pIdent The person identifier to check.
 * \return If \p pIdent is an external person.
 */
bool Person::isExternalIdent(const QString& pIdent)
{
    return pIdent.startsWith('e');
}

/*!
 * \brief Check if person identifier represents an "other" person.
 *
 * Checks if \p pIdent starts with the prefix that is used by createOtherIdent() to mark "other" identifiers.
 *
 * \param pIdent The person identifier to check.
 * \return If \p pIdent is an "other" person.
 */
bool Person::isOtherIdent(const QString& pIdent)
{
    return pIdent.startsWith('o');
}

//

/*!
 * \brief Extract membership number from internal person identifier.
 *
 * Extracts the membership number part of an internal identifier \p pInternalIdent that was generated with createInternalIdent().
 *
 * \param pInternalIdent An internal identifier.
 * \return The membership number.
 */
QString Person::extractMembershipNumber(const QString& pInternalIdent)
{
    return pInternalIdent.mid(3, -1);
}

/*!
 * \brief Extract suffix from external or "other" person identifier.
 *
 * Extracts the suffix part of the external identifier \p pExternalIdent that was generated with createExternalIdent().
 * This also works with an identifier for "other" people generated with createOtherIdent().
 *
 * \param pExternalIdent An external identifier.
 * \return The identifier suffix.
 */
QString Person::extractExtSuffix(const QString& pExternalIdent)
{
    QStringList tStrList = pExternalIdent.split('.');

    if (tStrList.size() == 2)
        return tStrList.at(1);

    return "";
}

//

/*!
 * \brief Get the person's last name.
 *
 * \return Person last name.
 */
QString Person::getLastName() const
{
    return lastName;
}

/*!
 * \brief Get the person's first name.
 *
 * \return Person first name.
 */
QString Person::getFirstName() const
{
    return firstName;
}

/*!
 * \brief Get the person's identifier.
 *
 * \return Person identifier.
 */
QString Person::getIdent() const
{
    return identifier;
}

/*!
 * \brief Get the person's qualifications.
 *
 * \return Person qualifications.
 */
Person::Qualifications Person::getQualifications() const
{
    return qualifications;
}

/*!
 * \brief Check, if the person is set active.
 *
 * \return Active/enabled state of the person.
 */
bool Person::getActive() const
{
    return active;
}

//

/*!
 * \brief Get the label for a personnel function.
 *
 * Get a (unique) nicely formatted label for \p pFunction to e.g. show it in the application as a combo box item.
 * Converting back is possible using labelToFunction().
 *
 * \param pFunction The personnel function to get a label for.
 * \return The corresponding label for \p pFunction.
 */
QString Person::functionToLabel(const Function pFunction)
{
    switch (pFunction)
    {
        case Function::_WF:
            return "WF";
        case Function::_SL:
            return "SL";
        case Function::_BF:
            return "BF";
        case Function::_WR:
            return "WR";
        case Function::_RS:
            return "RS";
        case Function::_PR:
            return "PR";
        case Function::_SAN:
            return "SAN";
        case Function::_FU:
            return "FU";
        case Function::_SR:
            return "SR";
        case Function::_ET:
            return "ET";
        case Function::_FUD:
            return "FüD";
        case Function::_OTHER:
            return "SONST";
        default:
            return "SONST";
    }
}

/*!
 * \brief Get the personnel function from its label.
 *
 * Get the personnel function corresponding to a (unique) label \p pFunction,
 * which can in turn be obtained from functionToLabel().
 *
 * \param pFunction The label representing the requested personnel function.
 * \return The personnel function corresponding to label \p pFunction.
 */
Person::Function Person::labelToFunction(const QString& pFunction)
{
    if (pFunction == "WF")
        return Function::_WF;
    else if (pFunction == "SL")
        return Function::_SL;
    else if (pFunction == "BF")
        return Function::_BF;
    else if (pFunction == "WR")
        return Function::_WR;
    else if (pFunction == "RS")
        return Function::_RS;
    else if (pFunction == "PR")
        return Function::_PR;
    else if (pFunction == "SAN")
        return Function::_SAN;
    else if (pFunction == "FU")
        return Function::_FU;
    else if (pFunction == "SR")
        return Function::_SR;
    else if (pFunction == "ET")
        return Function::_ET;
    else if (pFunction == "FüD")
        return Function::_FUD;
    else if (pFunction == "SONST")
        return Function::_OTHER;
    else
        return Function::_OTHER;
}

/*!
 * \brief Determine the order of two personnel functions.
 *
 * Checks, if \p pFirst should be ordered first with respect to \p pSecond.
 * The result is defined by the Person::Function integer values of \p pFirst
 * and \p pSecond, which are simply compared.
 *
 * \param pFirst Left-hand side of comparison.
 * \param pSecond Right-hand side of comparison.
 * \return 1, if \p pFirst is first, -1, if \p pSecond is first and 0 else.
 */
int Person::functionOrder(const Function pFirst, const Function pSecond)
{
    if (pFirst == pSecond)
        return 0;

    if (static_cast<int8_t>(pFirst) < static_cast<int8_t>(pSecond))
        return 1;
    else
        return -1;
}

//

/*!
 * \brief Get the label for a boat function.
 *
 * Get a (unique) nicely formatted label for \p pFunction to e.g. show it in the application as a combo box item.
 * Converting back is possible using labelToBoatFunction().
 *
 * \param pFunction The boat function to get a label for.
 * \return The corresponding label for \p pFunction.
 */
QString Person::boatFunctionToLabel(const BoatFunction pFunction)
{
    switch (pFunction)
    {
        case BoatFunction::_BG:
            return "BG";
        case BoatFunction::_RS:
            return "RS";
        case BoatFunction::_PR:
            return "PR";
        case BoatFunction::_SAN:
            return "SAN";
        case BoatFunction::_SR:
            return "SR";
        case BoatFunction::_ET:
            return "ET";
        case BoatFunction::_EXT:
            return "EXT";
        case BoatFunction::_OTHER:
            return "SONST";
        default:
            return "SONST";
    }
}

/*!
 * \brief Get the boat function from its label.
 *
 * Get the boat function corresponding to a (unique) label \p pFunction,
 * which can in turn be obtained from boatFunctionToLabel().
 *
 * \param pFunction The label representing the requested boat function.
 * \return The boat function corresponding to label \p pFunction.
 */
Person::BoatFunction Person::labelToBoatFunction(const QString& pFunction)
{
    if (pFunction == "BG")
        return BoatFunction::_BG;
    else if (pFunction == "RS")
        return BoatFunction::_RS;
    else if (pFunction == "PR")
        return BoatFunction::_PR;
    else if (pFunction == "SAN")
        return BoatFunction::_SAN;
    else if (pFunction == "SR")
        return BoatFunction::_SR;
    else if (pFunction == "ET")
        return BoatFunction::_ET;
    else if (pFunction == "EXT")
        return BoatFunction::_EXT;
    else if (pFunction == "SONST")
        return BoatFunction::_OTHER;
    else
        return BoatFunction::_OTHER;
}

/*!
 * \brief Determine the order of two boat functions.
 *
 * Checks, if \p pFirst should be ordered first with respect to \p pSecond.
 * The result is defined by the Person::BoatFunction integer values of
 * \p pFirst and \p pSecond, which are simply compared.
 *
 * \param pFirst Left-hand side of comparison.
 * \param pSecond Right-hand side of comparison.
 * \return 1, if \p pFirst is first, -1, if \p pSecond is first and 0 else.
 */
int Person::boatFunctionOrder(const BoatFunction pFirst, const BoatFunction pSecond)
{
    if (pFirst == pSecond)
        return 0;

    if (static_cast<int8_t>(pFirst) < static_cast<int8_t>(pSecond))
        return 1;
    else
        return -1;
}

//Private

/*!
 * \brief Create a hashed person identifier.
 *
 * Creates a person identifier that contains a hash made from the person name and its qualifications.
 *
 * Starts with the \p pPrefix followed by first letter of \p pFirstName and first letter of \p pLastName followed by a hash
 * made from a mixture of name and qualifications. Unlike with createInternalIdent(), here only some level of uniqueness
 * is introduced by the hash and hence a suffix \p pSuffix can be provided to distinguish conflicting identifiers.
 * The suffix is appended with a separating period, if not empty.
 *
 * \param pLastName Last name of the person.
 * \param pFirstName First name of the person.
 * \param pQualifications Qualifications of the person as comma-separated string.
 * \param pPrefix Identifier prefix.
 * \param pSuffix Identifier suffix (to achieve uniqueness).
 * \return The identifier.
 */
QString Person::createHashedIdent(const QString& pLastName, const QString& pFirstName, const QString& pQualifications,
                                  const char pPrefix, QString pSuffix)
{
    //Either no suffix or suffix prepended with a dot
    if (pSuffix != "")
        pSuffix.prepend('.');

    QString tRawStr = pLastName + pFirstName + pQualifications;
    QByteArray tByteArray = tRawStr.toUtf8();

    //Use similar format to internal ident; replace membership number by
    //a hash based on person name and qualifications; add suffix (if any)

    return QString(pPrefix) + pFirstName.left(1) + pLastName.left(1) +
            QString::fromStdString(
                QCryptographicHash::hash(tByteArray, QCryptographicHash::Algorithm::Md5).toHex().toStdString()
                ).left(8) + pSuffix;
}

//Qualifications struct

/*!
 * \brief Constructor.
 *
 * Sets each valid qualification contained in \p pQualifications to true and all others to false.
 *
 * \param pQualifications List of strings containing a single qualification each.
 */
Person::Qualifications::Qualifications(const QStringList& pQualifications) :
    eh(false),
    drsaS(false),
    sanA(false),
    faWrd(false),
    bfA(false),
    bfB(false),
    bos(false),
    sr1(false),
    et(false),
    wf(false),
    zf(false)
{
    for (const QString& quali : pQualifications)
    {
        if (quali == "EH")
            eh = true;
        else if (quali == "DRSA-S")
            drsaS = true;
        else if (quali == "SAN-A")
            sanA = true;
        else if (quali == "FA-WRD")
            faWrd = true;
        else if (quali == "BF-A")
            bfA = true;
        else if (quali == "BF-B")
            bfB = true;
        else if (quali == "BOS")
            bos = true;
        else if (quali == "SR-1")
            sr1 = true;
        else if (quali == "ET-1/2")
            et = true;
        else if (quali == "WF")
            wf = true;
        else if (quali == "ZUGF")
            zf = true;
    }
}

/*!
 * \brief Constructor.
 *
 * Sets each valid qualification contained in \p pQualifications to true and all others to false.
 * Calls QStringList overload of constructor with list created from \p pQualifications string split at ','.
 *
 * \param pQualifications Comma-separated list of single qualification strings.
 */
Person::Qualifications::Qualifications(const QString& pQualifications) :
    Qualifications(pQualifications.split(','))
{
}

//

/*!
 * \brief List all qualifications in principle available.
 *
 * \return List of strings that can be used in constructor to define qualifications.
 */
QStringList Person::Qualifications::listAllQualifications()
{
    return {"EH", "DRSA-S", "SAN-A", "FA-WRD", "BF-A", "BF-B", "BOS", "SR-1", "ET-1/2", "WF", "ZUGF"};
}

//

/*!
 * \brief Convert qualifications from old to new format.
 *
 * Converts a list of qualification strings using the old definitions from the format used in software versions
 * before 1.4.0 to a list using the new definitions from the format that is used since version 1.4.0.
 *
 * \param pQualifications Comma-separated list of single qualification strings in the format used before version 1.4.0.
 * \return Comma-separated list of single qualification strings in the format used since version 1.4.0.
 */
QString Person::Qualifications::convertLegacyQualifications(const QString& pQualifications)
{
    QStringList tQualis = pQualifications.split(',');

    for (QString& quali : tQualis)
    {
        if (quali == "EH")
        {}
        else if (quali == "RSA")
            quali = "DRSA-S";
        else if (quali == "SAN-A")
        {}
        else if (quali == "FA-WRD")
        {}
        else if (quali == "BF")
            quali = "BF-A";
        else if (quali == "BOS")
        {}
        else if (quali == "SR-1")
        {}
        else if (quali == "ET")
            quali = "ET-1/2";
        else if (quali == "WF")
        {}
        else if (quali == "ZUGF")
        {}
    }

    return Qualifications(tQualis).toString();
}

//

/*!
 * \brief Get a comma-separated list of possessed qualifications.
 *
 * \return Possessed qualifications as comma-separated string.
 */
QString Person::Qualifications::toString() const
{
    QString retVal;

    //Note: Must not change order of existing qualifications here!

    if (eh)
        retVal.append("EH,");
    if (drsaS)
        retVal.append("DRSA-S,");
    if (sanA)
        retVal.append("SAN-A,");
    if (faWrd)
        retVal.append("FA-WRD,");
    if (bfA)
        retVal.append("BF-A,");
    if (bfB)
        retVal.append("BF-B,");
    if (bos)
        retVal.append("BOS,");
    if (sr1)
        retVal.append("SR-1,");
    if (et)
        retVal.append("ET-1/2,");
    if (wf)
        retVal.append("WF,");
    if (zf)
        retVal.append("ZUGF,");

    if (retVal.endsWith(','))
        retVal.chop(1);

    return retVal;
}
